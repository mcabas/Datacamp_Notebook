select * from "Staging".dim_product;

TRUNCATE "Staging".dim_product;

INSERT INTO public.products(
	product_id, product_name, category, subcategory)
	VALUES ('PO750', 'test', 'testcategory', 'testimonio');

-- Looking at the problem
SELECT * FROM "Staging".dim_product;

-- Setting up schema & table structure
CREATE SCHEMA core;


CREATE TABLE core.dim_product (
    Product_PK int, 
    product_id varchar(5),
    product_name varchar(100),
    category varchar(50),
    subcategory varchar(50),
    brand varchar(50)
   );
   
-- Looking at the results
SELECT * FROM core.dim_product;


-- For the sake of the test
TRUNCATE TABLE "Staging".dim_product;

DELETE FROM "Staging".dim_product WHERE product_id > 'P0057';

---Test

INSERT INTO public.products(product_id, product_name, category, subcategory)
VALUES ('P0751', 'Red Apple (Milstaso)', 'Fruits & Vegetables', 'Fruits')
;

-- Looking at the results
SELECT * FROM core.dim_product;

----
----
----  CASE STUDY GUIDE
----
----

-- Setting up source data

CREATE TABLE public.sales
(
    transaction_id integer,
    transactional_date timestamp,
   product_id character varying,
    customer_id integer,
    payment character varying,
    credit_card bigint,
    loyalty_card character varying,
    cost character varying,
    quantity integer,
    price numeric,
    PRIMARY KEY (transaction_id)
);

SELECT * FROM public.sales;

-- FACT TABLE DESIGN
-- 1. CREATE DATEKEY
-- 2. INCLUEDE PRODUCT_FK
-- 3. PAYMENT DIM
-- 4. ADITTIONAL COLUMNS
    --- total_cost
    --- totol_price
    --- profit

-- Setting up sales fact table for staging

CREATE TABLE "Staging".sales
(
    transaction_id integer,
	transactional_date timestamp,
	product_id character varying,
    customer_id integer,
    payment character varying,
    credit_card bigint,
    loyalty_card character varying,
    cost numeric,
    quantity integer,
    price numeric,
    PRIMARY KEY (transaction_id)
);

-- Setting up sales fact table for core

CREATE TABLE core.sales
(
    transaction_id integer,
	transactional_date timestamp,
	transactional_date_fk bigint,
	product_id character varying,
	product_fk integer,
    customer_id integer,
    payment_fk integer,
    credit_card bigint,
    cost numeric,
    quantity integer,
    price numeric,
	total_cost numeric,
	total_price numeric,
	profit numeric,  
    PRIMARY KEY (transaction_id)
);

-- Setting up sales payment tables for staging and core


CREATE TABLE core.dim_payment
(
    payment_pk integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 ),
    payment character varying,
    loyalty_card character varying,
    PRIMARY KEY (payment_pk)
);

----

SELECT * FROM "Staging".sales;

--- LOAD PAYMENT DIM

SELECT DISTINCT 
    COALESCE(payment,'cash') as payment,  ---replaace nulls with cash
    loyalty_card
FROM "Staging".sales;

-----------------

SELECT 
	transaction_id ,
	transactional_date ,
	EXTRACT(year from transactional_date)*10000 + EXTRACT('month' from transactional_date)*100+EXTRACT('day' from transactional_date)as 	transactional_date_fk,
	f.product_id ,
	p.product_PK as product_FK,
	payment_PK as payment_FK,
    customer_id ,
    credit_card ,
   	cost  ,
    quantity ,
   	price
FROM "Staging".sales f
LEFT JOIN 
core.dim_payment d
ON d.payment = COALESCE(f.payment,'cash') AND d.loyalty_card=f.loyalty_card
LEFT JOIN core.dim_product p on p.product_id=f.product_id
order by transaction_id

----- verify job

SELECT * FROM core.sales;

SELECT * FROM core.dim_payment;

SELECT * FROM public.sales

----- create indexes

CREATE INDEX index_name on table_name [using method]
    (
    column_name [ASC | DESC],
    ...
    );

---

DROP INDEX core.customer_id_index

SELECT * from core.sales
WHERE customer_id = 4; 

CREATE INDEX customer_id_index on core.sales
    (
    customer_id ASC
    );